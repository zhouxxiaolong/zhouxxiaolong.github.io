{"pages":[],"posts":[{"title":"Activity启动模式","text":"解决Activity复用问题 Standard标准模式 SingleTop：栈顶复用 SingleTask栈内复用 先判断栈是否存在，不存在创建 该栈内是否有该activity实例，如果存在，clear top（弹出），该activity实例进入栈顶；如果不存在，创建该实例，并压入栈中 指定栈代码 12android:launchMode=&quot;singleTask&quot;android:taskAffinity=&quot;com.zxl.androidreview.other&quot; SingleInstance单例模式单独创建一个新栈，压入该实例 AllowTaskReparentingA应用： 1234567891011Button button2 = findViewById(R.id.btn_2);button2.setText(&quot;跳转三方应用CActivity&quot;);button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(); ComponentName cn = new ComponentName(&quot;com.zxl.myapplication&quot;, &quot;com.zxl.myapplication.CActivity&quot;); intent.setComponent(cn); startActivity(intent); } }); B应用： 1234567&lt;activity android:name=&quot;.CActivity&quot; android:launchMode=&quot;singleTask&quot; android:allowTaskReparenting=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt;","link":"/2019/01/21/Activity启动模式/"},{"title":"Activity生命周期","text":"本节内容将生命周期的情况分为两部分介绍，第一部分先了解典型的生命周期的7个部分及Activity的状态。第二部分会介绍Activity在一些特殊情况下的生命周期的经历过程。 创建过程 对于任何的一个activity，系统通过调用onCreate() 方法创建每一个Activity 的实例。 你必须实现onCreate() 方法，来执行基本的应用程序启动逻辑（只在activity的整个生命活动中发生一次）。例如，你的onCreate() 的实现应该定义了用户界面并且可能实例化一下类的变量。 一旦onCreate()完成执行，系统紧接着调用onStart()和onResume()方法。你的activity不会停留在Created或者Started状态。技术上，活动在onStart()调用后才变得对用户可见，但是此时的activity还在后台，onResume()紧紧相随，随后activity进入前台，用户可以看到。最后activity停留在Resumed状态直到某些事件发生来改变它，例如当接到一个电话，用户导航到另一个activity，或者设备屏幕关闭了。 典型情况下的生命周期分析 先上图，相信上图大家都很熟悉吧 在正常情况下，一个Activity从启动到结束会以如下顺序经历整个生命周期：onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onStop()-&gt;onDestory()。包含了六个部分，还有一个onRestart()没有调用，下面我们一一介绍这七部分内容。 onCreate()：当 Activity 第一次创建时会被调用。这是生命周期的第一个方法。在这个方法中，可以做一些初始化工作，比如调用setContentView去加载界面布局资源，初始化Activity所需的数据。当然也可借助onCreate()方法中的Bundle对象来回复异常情况下Activity结束时的状态（后面会介绍）。 onRestart()：表示Activity正在重新启动。一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart就会被调用。这种情形一般是用户行为导致的，比如用户按Home键切换到桌面、锁屏或者打开了另一个新的Activity，接着用户又回到了这个Actvity。（关于这部分生命周期的历经过程，后面会介绍。） onStart(): 表示Activity正在被启动，即将开始，这时Activity已经出现了，但是还没有出现在前台，无法与用户交互。这个时候可以理解为Activity已经显示出来，但是我们还看不到。 onResume():表示Activity已经可见了，并且出现在前台并开始活动。需要和onStart()对比，onStart的时候Activity还在后台，onResume的时候Activity才显示到前台。 onPause():表示 Activity正在停止，仍可见，正常情况下，紧接着onStop就会被调用。在特殊情况下，如果这个时候快速地回到当前Activity，那么onResume就会被调用（极端情况）。onPause中不能进行耗时操作，会影响到新Activity的显示。因为onPause必须执行完，新的Activity才会启动。 onStop():表示Activity即将停止，不可见，位于后台。可以做稍微重量级的回收工作，同样不能太耗时。 onDestory():表示Activity即将销毁，这是Activity生命周期的最后一个回调，可以做一些回收工作和最终的资源回收。 在平常的开发中，我们经常用到的就是 onCreate()和onDestory()，做一些初始化和回收操作。生命周期的几种普通情况 ①针对一个特定的Activity，第一次启动，回调如下：onCreate()-&gt;onStart()-&gt;onResume() ②用户打开新的Activiy的时候，上述Activity的回调如下：onPause()-&gt;onStop() ③再次回到原Activity时，回调如下：onRestart()-&gt;onStart()-&gt;onResume() ④按back键回退时，回调如下：onPause()-&gt;onStop()-&gt;onDestory() ⑤按Home键切换到桌面后又回到该Actitivy，回调如下：onPause()-&gt;onStop()-&gt;onRestart()-&gt;onStart()-&gt;onResume() ⑥调用finish()方法后，回调如下：onDestory()(以在onCreate()方法中调用为例，不同方法中回调不同，通常都是在onCreate()方法中调用) 特殊情况下的生命周期上面是普通情况下Activity生命周期的一些流程，但是在一些特殊情况下，Activity的生命周期的经历有些异常，下面就是两种特殊情况。①横竖屏切换在横竖屏切换的过程中，会发生Activity被销毁并重建的过程。 在了解这种情况下的生命周期时，首先应该了解这两个回调：onSaveInstanceState和onRestoreInstanceState。 在Activity由于异常情况下终止时，系统会调用onSaveInstanceState来保存当前Activity的状态。这个方法的调用是在onStop之前，它和onPause没有既定的时序关系，该方法只在Activity被异常终止的情况下调用。当异常终止的Activity被重建以后，系统会调用onRestoreInstanceState，并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象参数同时传递给onRestoreInstanceState和onCreate方法。因此，可以通过onRestoreInstanceState方法来恢复Activity的状态，该方法的调用时机是在onStart之后。其中onCreate和onRestoreInstanceState方法来恢复Activity的状态的区别：onRestoreInstanceState回调则表明其中Bundle对象非空，不用加非空判断。onCreate需要非空判断。建议使用onRestoreInstanceState。 横竖屏切换的生命周期：onPause()-&gt;onSaveInstanceState()-&gt; onStop()-&gt;onDestroy()-&gt;onCreate()-&gt;onStart()-&gt;onRestoreInstanceState-&gt;onResume() 可以通过在AndroidManifest文件的Activity中指定如下属性： android:configChanges = &quot;orientation| screenSize&quot; 来避免横竖屏切换时，Activity的销毁和重建，而是回调了下面的方法： 1234@Overridepublic void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig);} 圈个重点 onSaveInstanceState 调用在onStop之前，但是跟onPause 没有既定关系，可以在其前后 onRestoreInstanceState 在onStart之后。 ②资源内存不足导致优先级低的Activity被杀死Activity优先级的划分和下面的Activity的三种运行状态是对应的。 (1) 前台Activity——正在和用户交互的Activity，优先级最高。 (2) 可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户交互。 (3) 后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低。 当系统内存不足时，会按照上述优先级从低到高去杀死目标Activity所在的进程。我们在平常使用手机时，能经常感受到这一现象。这种情况下数组存储和恢复过程和上述情况一致，生命周期情况也一样。 Activity的三种运行状态①Resumed（活动状态） 又叫Running状态，这个Activity正在屏幕上显示，并且有用户焦点。这个很好理解，就是用户正在操作的那个界面。 ②Paused（暂停状态） 这是一个比较不常见的状态。这个Activity在屏幕上是可见的，但是并不是在屏幕最前端的那个Activity。比如有另一个非全屏或者透明的Activity是Resumed状态，没有完全遮盖这个Activity。 ③Stopped（停止状态） 当Activity完全不可见时，此时Activity还在后台运行，仍然在内存中保留Activity的状态，并不是完全销毁。这个也很好理解，当跳转的另外一个界面，之前的界面还在后台，按回退按钮还会恢复原来的状态，大部分软件在打开的时候，直接按Home键，并不会关闭它，此时的Activity就是Stopped状态。","link":"/2017/06/03/Activity生命周期/"},{"title":"CustomView重要函数解析","text":"CustomView重要函数解析零：重要的函数 Android开发中，对于自定义View，分为两种，一种是自定义控件（继承View类），另一种是自定义布局容器（继承ViewGroup）。如果是自定义控件，则一般需要重载两个方法，一个是onMeasure()，用来测量控件尺寸，另一个是onDraw()，用来绘制控件的UI。而自定义布局容器，则一般需要实现/重载三个方法，一个是onMeasure()，也是用来测量尺寸；一个是onLayout()，用来布局子控件；还有一个是dispatchDraw()，用来绘制UI。 1. 重要函数的回调顺序 onFinishInflate() 当View中所有的子控件均被映射成xml后触发 onMeasure( int , int ) 确定所有子元素的大小 onLayout( boolean , int , int , int , int ) 当View分配所有的子元素的大小和位置时触发 onSizeChanged( int , int , int , int ) 当view的大小发生变化时触发 onDraw(Canvas) view渲染内容的细节 onKeyDown( int , KeyEvent) 有按键按下后触发 onKeyUp( int , KeyEvent) 有按键按下后弹起时触发 onTrackballEvent(MotionEvent) 轨迹球事件 onTouchEvent(MotionEvent) 触屏事件 onFocusChanged( boolean , int , Rect) 当View获取或失去焦点时触发 onWindowFocusChanged( boolean ) 当窗口包含的view获取或失去焦点时触发 onAttachedToWindow() 当view被附着到一个窗口时触发 onDetachedFromWindow() 当view离开附着的窗口时触发，该方法和 onAttachedToWindow() 是相反。 onWindowVisibilityChanged(int) 当窗口中包含的可见的view发生变化时触发 2. new CustomView(context)生成的view的回调顺序123456789101112131415st=&gt;start: 开始e=&gt;end: 结束op1=&gt;operation: onDetachedFromWindowop2=&gt;operation: onAttachedToWindowop3=&gt;operation: onMeasureop4=&gt;operation: onSizeChangedop5=&gt;operation: onLayoutop6=&gt;operation: onDrawst-&gt;op1op1-&gt;op2op2-&gt;op3op3-&gt;op4op4-&gt;op5op5-&gt;op6op6-&gt;e 3. 从xml布局中生成的view的回调顺序123456789101112131415st=&gt;start: 开始e=&gt;end: 结束op1=&gt;operation: onFinishInflateop2=&gt;operation: onAttachedToWindowop3=&gt;operation: onMeasureop4=&gt;operation: onSizeChangedop5=&gt;operation: onLayoutop6=&gt;operation: onDrawst-&gt;op1op1-&gt;op2op2-&gt;op3op3-&gt;op4op4-&gt;op5op5-&gt;op6op6-&gt;e Android studio 推荐使用Lifecycle Sorter插件，可以按照生命周期对回调方法进行排序。 一、构造函数 一共有四个构造函数 123456789101112131415161718public CustomViewDemo(Context context) { this(context, null); }public CustomViewDemo(Context context, @Nullable AttributeSet attrs) { //调用了三个参数的构造函数，明确指定第三个参数 this(context, attrs, 0); }public CustomViewDemo(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { //此处调了四个参数的构造函数，无视即可 this(context, attrs, defStyleAttr, 0); } //在API21的时候才添加上，暂不考虑。public CustomViewDemo(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); } 调用一个参数的构造函数的方式：CustomViewDemo customViewDemo=new CustomViewDemo(this); 调用两个参数的构造函数的方式：123&lt;com.zxl.customview.custom.view.CustomViewDemo android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 二、onMeasure(测量View大小)measure是测量的意思，那么onMeasure()方法顾名思义就是用于测量视图的大小的。View系统的绘制流程会从ViewRoot的performTraversals()方法中开始，在其内部调用View的measure()方法。measure()方法接收两个参数，widthMeasureSpec和heightMeasureSpec，这两个值分别用于确定视图的宽度和高度的规格和大小。 12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int widthsize = MeasureSpec.getSize(widthMeasureSpec); //取出宽度的确切数值 int widthmode = MeasureSpec.getMode(widthMeasureSpec); //取出宽度的测量模式 int heightsize = MeasureSpec.getSize(heightMeasureSpec); //取出高度的确切数值 int heightmode = MeasureSpec.getMode(heightMeasureSpec); //取出高度的测量模式} MeasureSpec的值由specSize和specMode共同组成的，其中specSize记录的是大小，specMode记录的是规格。specMode一共有三种类型，如下所示： 模式 第二格表头 UNSPECIFIED 默认值，父控件没有给子view任何限制，子View可以设置为任意大小。 EXACTLY 表示父控件已经确切的指定了子View的大小。 AT_MOST 表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。 而上面的测量模式跟布局时的wrap_content、match_parent以及写成固定的尺寸有什么对应关系呢？ match_parent—&gt;EXACTLY。怎么理解呢？match_parent就是要利用父View给我们提供的所有剩余空间，而父View剩余空间是确定的，也就是这个测量模式的整数里面存放的尺寸。 wrap_content—&gt;AT_MOST。怎么理解：就是我们想要将大小设置为包裹我们的view内容，那么尺寸大小就是父View给我们作为参考的尺寸，只要不超过这个尺寸就可以啦，具体尺寸就根据我们的需求去设定。 固定尺寸（如100dp）—&gt;EXACTLY。用户自己指定了尺寸大小，我们就不用再去干涉了，当然是以指定的大小为主啦。 注意：如果对View的宽高进行修改了，不要调用super.onMeasure(widthMeasureSpec,heightMeasureSpec);要调用setMeasuredDimension(widthsize,heightsize); 这个函数。三、onLayout(确定子view布局)确定布局的函数是onLayout，它用于确定子View的位置，在自定义ViewGroup中会用到，他调用的是子View的layout函数。 在自定义ViewGroup中，onLayout一般是循环取出子View，然后经过计算得出各个子View位置的坐标值，然后用以下函数设置子View位置。 四、onSizeChanged(确定view的大小)12345@Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); Log.e(TAG, &quot;onSizeChanged&quot;); } 有四个参数：w：宽度h：高度oldw：上一次宽度oldh：上一次高度 重点关注w，h，这两个是view的最终大小 五、onDraw和dispatchDraw（绘制内容） 绘制VIew本身的内容，通过调用View.onDraw(canvas)函数实现绘制自己的孩子通过dispatchDraw（canvas）实现 六、dispatchTouchEvent和onTouchEvent重点（正在更新中…） 七、onFocusChanged该方法是焦点改变的回调方法","link":"/2017/04/23/CustomView重要函数解析/"},{"title":"Docker内Nexus搭建","text":"想玩Docker很久了，但是一直没有机会，最近打算搭建一个Nexus私服，那就很巧啊，依赖docker搭建nexus私服。 安装Docker使用 Homebrew 安装brew cask install docker Docker 加速器在国内使用 Docker 的话，需要配置加速器，在菜单中点击 Preferences…，然后查看 Daemon 标签，在其中的 Registry mirrors 部分里可以点击加号来添加加速器地址，最后 Apply&amp;Restart。 从 阿里镜像站点，获取您的专属加速器地址。 安装Nexus安装最新nexus2或者3nexus2docker pull sonatype/nexus nexus3（推荐）docker pull sonatype/nexus3 启动容器，命名：docker run -d -p 8081:8081 --name nexus sonatype/nexus3 以上两步骤截图 查看docker起的服务docker ps 如上图所示，关闭docker后，重启docker，先执行docker ps ，查看运行的容器，发现nexus未运行，执行docker start 容器名/id即可。 访问 是不是很简单啊！！！！ 一些常用仓库http://jcenter.bintray.com/http://maven.aliyun.com/nexus/content/groups/public/https://registry.npm.taobao.orghttps://jitpack.io","link":"/2017/09/22/Docker内Nexus搭建/"},{"title":"Java内功之SOLID设计原则","text":"SOLID设计原则 单一职责原则（Single Responsibility Principle,SRP） 开闭原则（Open Closed Principle） 里氏代换原则（Liskov Substitution Principle,LSP） 接口隔离原原则（Interface Segregation Principle,ISP） 依赖倒置原则（Dependency Inversion Principle） 单一职责原则 A class should have only one single responsibility.A class should have only one reason to change. 简单来说就是:一个类应该只有一个职责(只有一个潜在的改变能影响这个类); 作用 高内聚，低耦合 类结构、逻辑清晰明了，提高代码可读性，易于维护，易于阅读 开闭原则对象或实体应该对扩展开放，对修改封闭。 作用可拓展，稳定 里氏代换原则简单来说就是:父类可以出现的地方,子类也可以出现,父类都可以被子类代替而无需改动. 作用里氏代换原则是实现开闭原则的重要方式之一，可以很方便的扩展功能。 接口隔离原则不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法。 作用 解耦 方便使用 依赖倒置原则 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 抽象不应该依赖于细节，细节应该依赖于抽象(抽象指的是接口或者抽象类，细节就是具体的实现类) 理念:以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多，依赖倒置原则的核心思想也是面向接口编程 倒置？？？？（什么鬼，黑人问号脸）传统：高层模块依赖低层模块提供的抽象，低层模块实现抽象。优点： 这是通常意义的面向接口编程，或开闭原则； 抽象接口就是低层模块可对外提供的服务。 一定程度上降低了耦合，使得低层模块易于扩展。 缺点： 高层模块还是依赖低层模块，只不过依赖的是低层抽象。低层抽象还是有较高变动性，而且还是会传递；使得高层模块的可重用性降低。 怎么倒置 高层模块为它所需要的服务声明一个抽象接口，低层模块实现了这些抽象接口。 把高层模块和低层模块交互行为抽象出来，做到互不依赖，都依赖于提取出来的抽象。 优点：你会发现高层完全不依赖底层模块，不受低层模块易变性影响(比如更换http请求框架)，增加高略层的可重用性。高层模块和低层模块彻底解耦，都很容易实现扩展； 缺点：增加了一层抽象层，增加实现难度；对一些简单的调用关系来说，可能是得不偿失的。对一些稳定的调用关系，反而增加复杂度，是不正确的。 总结 依赖于抽象 倒置 声明未完待补充本文有个人见解，如本人理解有偏差，欢迎指正。","link":"/2017/09/17/Java内功之SOLID设计原则/"},{"title":"Fragment（片段）","text":"Fragment的个人理解Fragment是Activity模块化的组成部分，Fragment必须嵌套在Activity中，其生命周期直接受宿主 Activity 生命周期的影响。但是，它们具有自己的生命周期。 设计原理（官方解释）Android 在 Android 3.0（API 级别 11）中引入了片段，主要是为了给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持。由于平板电脑的屏幕比手机屏幕大得多，因此可用于组合和交换 UI 组件的空间更大。利用片段实现此类设计时，您无需管理对视图层次结构的复杂更改。 通过将 Activity 布局分成片段，您可以在运行时修改 Activity 的外观，并在由 Activity 管理的返回栈中保留这些更改。 生命周期 onAttach()在片段已与 Activity 关联时调用（Activity 传递到此方法内）。 onCreate()系统会在创建片段时调用此方法。您应该在实现内初始化您想在片段暂停或停止后恢复时保留的必需片段组件。 onCreateView()系统会在片段首次绘制其用户界面时调用此方法。 要想为您的片段绘制 UI，您从此方法中返回的 View 必须是片段布局的根视图。如果片段未提供 UI，您可以返回 null。 onActivityCreated()在 Activity 的 onCreate() 方法已返回时调用。 onPause()系统将此方法作为用户离开片段的第一个信号（但并不总是意味着此片段会被销毁）进行调用。 您通常应该在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。 onDestroyView()在移除与片段关联的视图层次结构时调用。 onDetach()在取消片段与 Activity 的关联时调用。 生命周期分析当一个fragment被创建的时候，它会经历以下状态.onAttach()onCreate()onCreateView()onActivityCreated() 当这个fragment对用户可见的时候，它会经历以下状态。onStart()onResume() 当这个fragment进入“后台模式”的时候，它会经历以下状态。onPause()onStop() 当这个fragment被销毁了（或者持有它的activity被销毁了），它会经历以下状态。onPause()onStop()onDestroyView()onDestroy() // 本来漏掉类这个回调，感谢xiangxue336提出。onDetach() 就像activitie一样，在以下的状态中，可以使用Bundle对象保存一个fragment的对象。onCreate()onCreateView()onActivityCreated() fragments的大部分状态都和activitie很相似，但fragment有一些新的状态。onAttached() —— 当fragment被加入到activity时调用（在这个方法中可以获得所在的activity）。onCreateView() —— 当activity要得到fragment的layout时，调用此方法，fragment在其中创建自己的layout(界面)。onActivityCreated() —— 当activity的onCreated()方法返回后调用此方法onDestroyView() —— 当fragment中的视图被移除的时候，调用这个方法。onDetach() —— 当fragment和activity分离的时候，调用这个方法。","link":"/2017/09/08/Fragment生命周期/"},{"title":"Java内功之设计模式------单例模式(Singleton Pattern)","text":"简介单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。脑子里先回忆一下大概有几种写法。3？4？种。。。 懒汉式，线程不安全123456789101112131415 ///****************************************** ///****************懒汉式1******************** ///***优点：写法简单,实现懒加载用的时候才初始化 ///***缺点：多线程并行的时候，就会创建多个实例。 ///******************************************public class Singleton { private static Singleton instance_lan1; private Singleton (){} public static Singleton getInstance_lan1() { // 懒汉式创建实例对象，但是多线程并行的时候，就会创建多个实例。 if (instance_lan1 == null) { instance_lan1 = new Singleton(); } return instance_lan1; }} 懒汉式，线程安全12345678910111213///******************************************///****************懒汉式2********************///***优点：写法简单,实现懒加载用的时候才初始化,多线程并行的时候，就不会创建多个实例///***缺点：影响效率，因为在任何时候只能有一个线程调用 getInstance_lan2() 方法。///******************************************private static Singleton instance_lan2;private Singleton (){}public static synchronized Singleton getInstance_lan2() { if (instance_lan2 == null) { instance_lan2 = new Singleton(); } return instance_lan2;} 饿汉式,简单粗暴有效，但是不高效1234567891011///******************************************///****************饿汉式*********************///***优点：简单///***缺点：一旦类被加载，单例就会初始化，没有实现懒加载。/// 而且当实现了Serializable接口后，反序列化时单例会被破坏。///******************************************private static final Singleton INSTANCE_E = new Singleton();public static Singleton getInstance_e() { return INSTANCE_E;} 静态内部类1234567891011///******************************************///****************静态内部类******************///***优点：不会出现线程问题，可以实现延迟加载。完美。这种方法也是《Effective Java》上所推荐的。///******************************************private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton();}public static final Singleton getInstance() { return SingletonHolder.INSTANCE;} 枚举123456public enum EnumSingleton{ INSTANCE; public void print() { System.out.println(&quot;hello,single&quot;); }} 如何使用： 123public static void main(String[] args) { EnumSingleton.INSTANCE.print(); } 我们可以通过EnumSingleton.INSTANCE来访问实例,卧槽，这么简单，为啥见到的不多呢，我也不知道，唯一的限制就是java 1.5后。 总结《Effective Java》上大概有五种写法，我列举了其中几例能能一下子想到的方式，其中，一般情况下推荐使用饿汉式，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。 项目地址github仓库","link":"/2017/10/08/Java内功之设计模式-单例模式/"},{"title":"Java内功之UML类图和时序图","text":"UML笔记 类之间的关系类的继承结构表现在UML中为：泛化(generalize)与实现(realize)继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系 泛化关系(generalization)泛化关系用一条带空心箭头的直接表示；如下图表示（SUV继承自小汽车）；注泛化关系表现为继承非抽象类 实现关系(realize)实现关系用一条带空心箭头的虚线表示；注实现关系表现为继承抽象类； 聚合关系(aggregation)聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 关联关系(association)关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 依赖关系(dependency)依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖B；他描述一个对象在运行期间会用到另一个对象的关系； 双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖 依赖关系体现为，类构造方法和类方法的传入参数，例子如下。 123class ClassA{ void depend(ClassB classB){}} 时序图时序图中包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。","link":"/2017/09/17/Java内功之UML类图和时序图/"},{"title":"Java内功之设计模式------工厂方法模式(Factory Method Pattern)","text":"简介工厂方法模式是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。 角色与结构工厂方法模式是简单工厂模式的进一步抽象和推广。 你可以发现工厂方法只是在简单工厂模式的基础上抽象了工厂。 角色 抽象工厂角色：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。 具体工厂角色：担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类。 抽象导出角色：工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。 具体导出角色：这个角色实现了抽象导出角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。 引入考虑一个简单的软件应用场景。有一个生产纸片玩具的厂，生产三种玩具： 红色圆形 CircleShape 蓝色矩形 RectShape 黄色三角形 TriangleShape 这三种玩具由两种不同类型的材质做成，一种是纸卡片，另一种是塑料。 咦，怎么会怎么复杂的依赖呢，是不是好蠢。 优化下 优缺点优点 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 缺点 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 适用环境 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 代码Gist 123public interface Factory { public ShapeProduct create(String type);} 123public interface ShapeProduct { public void drawColor();} 123456789101112131415public class PaperFactory implements Factory { @Override public ShapeProduct create(String type) { if (&quot;Circle&quot;.equals(type)) { return new PaperCircleShape(); } else if (&quot;Rect&quot;.equals(type)) { return new PaperRectShape(); } else if (&quot;Triangle&quot;.equals(type)) { return new PaperTriangleShape(); } else { throw new RuntimeException(&quot;不能生产该形状纸片&quot;); } }} 123456789101112131415public class PlasticFactory implements Factory { @Override public ShapeProduct create(String type) { if (&quot;Circle&quot;.equals(type)) { return new PlasticCircleShape(); } else if (&quot;Rect&quot;.equals(type)) { return new PlasticRectShape(); } else if (&quot;Triangle&quot;.equals(type)) { return new PlasticTriangleShape(); } else { throw new RuntimeException(&quot;不能生产该形状塑料&quot;); } }} 1234567public class PaperCircleShape implements ShapeProduct { @Override public void drawColor() { System.out.println(&quot;红色圆形纸片&quot;); }} 123456789public class PaperRectShape implements ShapeProduct { @Override public void drawColor() { System.out.println(&quot;蓝色矩形纸片&quot;); }} 12345678public class PaperTriangleShape implements ShapeProduct { @Override public void drawColor() { System.out.println(&quot;黄色三角形纸片&quot;); }} 1234567public class PlasticCircleShape implements ShapeProduct { @Override public void drawColor() { System.out.println(&quot;红色圆形塑料&quot;); }} 1234567public class PlasticRectShape implements ShapeProduct { @Override public void drawColor() { System.out.println(&quot;蓝色矩形塑料&quot;); }} 1234567public class PlasticTriangleShape implements ShapeProduct { @Override public void drawColor() { System.out.println(&quot;黄色三角形塑料&quot;); }}","link":"/2017/09/27/Java内功之设计模式-工厂方法模式/"},{"title":"Java内功之设计模式------建造者（Builder）模式（Builder Pattern）","text":"简介造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 Builder模式，对于Android开发人员应该不陌生吧，AlertDialog.Builder等等等。 角色与结构 角色 Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 引入考虑一个手机制造代工厂。生产两款手机iPhone 8和Nexus 5x。 代码github仓库 抽象建造者类Builder 123456789101112131415public interface Builder { public void name(); public void buildCPU(); public void buildRAM(); public void buildScreen(); public void buildMainBoard(); public Phone create();} 产品类 Phone 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Phone { private String name; private String cpu; private String ram; private String screen; private String mainBoard; /** * Default constructor */ public Phone() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCpu() { return cpu; } public void setCpu(String cpu) { this.cpu = cpu; } public String getRam() { return ram; } public void setRam(String ram) { this.ram = ram; } public String getScreen() { return screen; } public void setScreen(String screen) { this.screen = screen; } public String getMainBoard() { return mainBoard; } public void setMainBoard(String mainBoard) { this.mainBoard = mainBoard; } @Override public String toString() { return &quot;Phone{&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, cpu=&apos;&quot; + cpu + &apos;\\&apos;&apos; + &quot;, ram=&apos;&quot; + ram + &apos;\\&apos;&apos; + &quot;, screen=&apos;&quot; + screen + &apos;\\&apos;&apos; + &quot;, mainBoard=&apos;&quot; + mainBoard + &apos;\\&apos;&apos; + &apos;}&apos;; }} 具体建造者类 IPhoneBuilder 1234567891011121314151617181920212223242526272829303132333435363738public class IPhoneBuilder implements Builder { private Phone phone = new Phone(); public IPhoneBuilder() { } @Override public void name() { phone.setName(&quot;iPhone 8&quot;); } @Override public void buildCPU() { phone.setCpu(&quot;A11&quot;); } @Override public void buildRAM() { phone.setRam(&quot;4G&quot;); } @Override public void buildScreen() { phone.setScreen(&quot;Apple Screen&quot;); } @Override public void buildMainBoard() { phone.setMainBoard(&quot;Apple MainBoard&quot;); } @Override public Phone create() { return phone; }} 具体建造者类 NexusBuilder 1234567891011121314151617181920212223242526272829303132333435363738public class NexusBuilder implements Builder { private Phone phone = new Phone(); public NexusBuilder() { } @Override public void name() { phone.setName(&quot;Nexus 5x&quot;); } @Override public void buildCPU() { phone.setCpu(&quot;Nexus CPU&quot;); } @Override public void buildRAM() { phone.setRam(&quot;3G&quot;); } @Override public void buildScreen() { phone.setScreen(&quot;Nexus Screen&quot;); } @Override public void buildMainBoard() { phone.setMainBoard(&quot;Nexus MainBoard&quot;); } @Override public Phone create() { return phone; }} 导演者类 Director1234567891011121314151617181920public class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } /** * 可以在客户端处分别赋值 */ public void construct() { builder.name(); builder.buildCPU(); builder.buildRAM(); builder.buildMainBoard(); builder.buildScreen(); }} 客户端类Client 123456789public class Client { public static void main(String[] args) { Builder iPhoneBuilder = new IPhoneBuilder(); Director director = new Director(iPhoneBuilder); director.construct(); Phone product = iPhoneBuilder.create(); System.out.println(product.toString()); }} 优缺点优点 在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。 缺点 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。","link":"/2017/10/08/Java内功之设计模式-建造者（Builder）模式/"},{"title":"Java内功之设计模式------抽象工厂模式(Abstract Factory Pattern)","text":"本文先介绍一些抽象工厂的设计，然后尝试总结一下三种工厂模式。 简介抽象工厂模式：提供一个接口，用于创建相关或相互依赖对象的家族，而无须指定它们具体的类。 抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。 在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。 角色与结构 为了更清晰地理解工厂方法模式，需要先引入两个概念： 产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 角色 AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 引入源码先以本例子做说明，本人觉得本例子还是不够有代表性，所以后续会补充。 优缺点优点 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。 适用环境 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 系统中有多于一个的产品族，而每次只使用其中某一产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 总结三种工厂模式 所有的工厂都是用来封装对象的创建过程 简单工厂，一种简单的方式，实现具体类的解耦。 工厂方法使用继承（实现）:把对象的创建委托给子类，子类实现工厂方法来创建对象。 抽象工厂使用对象的组合：对象的创建被实现在工厂接口所暴露出来的方法中。 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。 工厂方法允许讲类的实例化延迟到子类中进行 针对接口编程：其实面向实现编程并没有错，有错的是”改变”，针对接口编程的好处就是能避免牵一发而动全身。","link":"/2017/10/06/Java内功之设计模式-抽象工厂模式/"},{"title":"Java内功之设计模式------简单工厂模式( Simple Factory Pattern )","text":"简介简单工厂模式是类的创建模式，又称静态工厂方法模式。 角色与结构 角色： 工厂类（Creator）：工厂方法模式的核心。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体java类实现。 抽象产品（Product）：是工厂方法模式所创建的对象（具体产品）的父类。它往往是抽象类或者是一个接口。 具体产品（Concrete Product）：工厂方法产出的对象。它往往是一个具体java类。 引入考虑一个简单的软件应用场景。有一个生产纸片玩具的厂，生产三种玩具： 红色圆形纸片 CircleShape 蓝色矩形纸片 RectShape 黄色三角形纸片 TriangleShape 优缺点优点 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 缺点 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用环境 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 代码gist地址 ShapeProduct123public interface ShapeProduct { void drawColor();} CircleShape12345678910111213public class CircleShape implements ShapeProduct { /** * Default constructor */ public CircleShape() { } @Override public void drawColor() { System.out.println(&quot;红色圆形纸片&quot;); }} RectShape123456789101112131415public class RectShape implements ShapeProduct { /** * Default constructor */ public RectShape() { } /** * */ public void drawColor() { System.out.println(&quot;蓝色矩形纸片&quot;); }} TriangleShape123456789101112131415public class TriangleShape implements ShapeProduct { /** * Default constructor */ public TriangleShape() { } /** * */ public void drawColor() { System.out.println(&quot;黄色三角形纸片&quot;); }} Creator12345678910111213141516class Creator { public static ShapeProduct simpleFactory(String fruitType) { if (&quot;CircleShape&quot;.equals(fruitType)) { return new CircleShape(); } else if (&quot;RectShape&quot;.equals(fruitType)) { return new RectShape(); } else if (&quot;TriangleShape&quot;.equals(fruitType)) { return new TriangleShape(); } else { throw new RuntimeException(&quot;不能生产该形状纸片&quot;); } }} Client123456public class Client { public static void main(String[] args) { ShapeProduct circleShape = Creator.simpleFactory(&quot;CircleShape&quot;); circleShape.drawColor(); }}","link":"/2017/09/24/Java内功之设计模式-简单工厂模式/"},{"title":"Java内功之设计模式------适配器模式","text":"(Adapter Pattern) 简介适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 对于Android开发人员，适配器应该再熟悉不过了。其实对于大家，适配器太普遍了，展示下用在iPhone上的两种适配器。常用于iPhone的充电器口是Lightning，而一般Micro Usb口用于老款Android机器。耳机，市面上普遍的是3.5mm口耳机，苹果出了Lightning口耳机。 角色与结构适配器模式包含如下角色： Target：目标抽象类 Adapter：适配器类 Adaptee：适配者类 Client：客户类 两种实现方式对象适配器 类适配器 代码请参考github仓库，这里就不占代码了。github 优缺点优点 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。类适配器模式还具有如下优点：由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。对象适配器模式还具有如下优点：一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。缺点类适配器模式的缺点如下：对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。对象适配器模式的缺点如下：与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 总结 结构型模式描述如何将类或者对象结合在一起形成更大的结构。 适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。 在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。 适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。 适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。","link":"/2017/10/09/Java内功之设计模式-适配器模式/"},{"title":"Java内功之面向对象理解","text":"从本文开始，打算梳理Java基础知识，方便我以及各位面试急需梳理知识点的同学。 面向对象三大特征：封装、继承、多态 封装 隐藏内部细节 通过将细节私有化，把接口和实现分离开来 抽象出方法，复用，便于修改，提高效率 提高代码可读性（封装的方法名更易看得懂） 继承（extends）优势子类继承父类后拥有父类的属性成员,可以很好的复用已有的类,不需要再重复写方法属性了。 不足 子类拥有了父类所有的属性 父类改变会牵动所有子类 提倡组合,少用继承 多态我们只有在运行的时候才会知道引用变量所指向的具体实例对象。 举个栗子,来阐述父类 Wine(酒)子类 茅台，五粮液，剑南春我们只是通过酒这一个父类就能够引用不同的子类，这就是多态茅台 maotai=new 茅台();Wine maotai=new 茅台(); 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 重写重载的区别重写是重写父类的方法重载是重载一个类里的方法 多态的实现方式 方式一：重写 方式二：接口 方式三：抽象类和抽象方法 优势 可扩充性 可替换性 灵活性 不足 父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了。 未完待补充，欢迎各路大神指正！","link":"/2017/09/14/Java内功之面向对象理解/"},{"title":"Mac上将socks5代理转为http代理","text":"在 mac 上使用 ss 的时候创建的是 socks5 代理，浏览器可以正常设置使用，不过在 shell 中一些程序无法使用 socks5 代理，而需要使用 http 代理，通过设置 http_proxy 环境变量，就可以让 shell 通过 http 代理来访问网络。polipo 这款工具就可以帮助我们将 socks5 代理转换为 http 代理。 安装brew install polipo 创建 http 代理假设我们 ss 的 socks5 代理端口为 1080。 polipo socksParentProxy=localhost:1080 使用","link":"/2017/11/24/Mac上将socks5代理转为http代理/"},{"title":"我","text":"自吹的页面，还没打算好写什么","link":"/1992/10/30/first/"},{"title":"Mac搭建github Page的Hexo免费个人博客","text":"1.基础准备 github账号 安装git 安装node.js、npm（本人使用淘宝镜像） 2.创建repo 需要注意的地方，我都做了标注，如图所示，本人账号zhouxxiaolong，repository name 就必须是zhouxxiaolong.github.io;其他未标注选项默认就好。 3.配置SSH key这一步并不重要，配置SSH key与否，并不影响博客的搭建和使用，只是配置了之后，更新博客方便一点，不用每次都输用户名和密码。 打开终端，输入如下命令 12cd .sshls -la 检查终端输出的文件列表中是否已经存在id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么你可以跳过步骤 \u0010创建SSH key$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;注：此处邮箱为注册github账号的邮箱回车，接着会提示你，让你输入文件名，直接回车会创建使用默认文件名的文件（推荐使用默认文件名）；然后会提示你输入两次密码（输入密码之后没有反馈，显示还是空白，但是你确实已经输入了），当然密码也可以不输，直接回车，如果这里没有输入密码，以后提交博客更新的时候就不需要输入密码了。 添加SSH key到github经过第二步，如果你没有指定文件名（也就是使用的默认文件名），那么你的.ssh文件夹下，应该有一个id_rsa.pub文件了，打开该文件，复制里面的文本。然后登陆github，点击右上角头像右边的三角图标，点击Settings，然后在左边菜单栏点击SSH and GPG keys，点击new ssh key，title 随意填，在key 栏填入你复制的内容，点击add ssh key，就可以添加一个ssh key了。 验证SSH key是否配置成功终端输入：ssh -T git@github.com回车，你会看到如下回复，说明你的ssh key添加成功了。Hi zhouxxiaolong! You’ve successfully authenticated, but GitHub does not provide shell access.如果过程中提示你perimission deny相关错误，就在命令前加上sudo 然后执行命令的时候输入你的appleid密码应该就可以了。sudo用来说明用管理员权限运行。 4.安装Hexo 终端输入： npm install -g hexo 初始化，创建所需资源 新建任意名字文件夹，cd进入该文件夹后，执行如下命令 12hexo initnpm install 生成并发布 12hexo g // 全拼是：hexo generate，可以简写成 hexo ghexo s // 全拼是：hexo server，可以简写成 hexo s 这样就开启了一个本地博客服务器，打开浏览器，在地址栏输入http://localhost:4000，就可以查看本地博客了，hexo默认生成了一片hello world博客。注：以上hexo开头的命令，执行目录必须是你创建的博客文件夹目录，因为只有在那个文件夹下才有创建和发布hexo的所有资源。 5.同步Hexo到Github 安装 npm install hexo-deployer-git --save 打开本地博客目录的_config.yml文件，编辑其中的deploy节点 1234deploy:type: gitrepository: https://github.com/zhouxxiaolong/zhouxxiaolong.github.io.gitbranch: master 注：“: ”后面的空格，这是个坑repository地址从下图中即可获取保存即可当然可以使用SSH地址作为repository地址，点击右上角Use SSH，之后操作相同。 生成和发布 123hexo clean // clean本地项目，防止缓存hexo g // 根据你编辑的md格式的博客，生成静态网页hexo d // 将本地博客发布到github 然后，在浏览器地址栏输入yourusername.github.io就可以访问你的博客了，别人也可以通过这个地址访问你的博客。 6.Hexo常用命令行1234567hexo init //在指定目录执行该命令，会将当前目录初始化为hexo站点，生成hexo站点所需的一切文件hexo new “my new blog title” //新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。hexo clean // 清除缓存，如果对本地文件做了修改，同步到远程验证修改的效果之前，先clean，清除缓存hexo generate // 可以简写成hexo g 根据markdown文件生成静态文件hexo server // 或者简写成hexo s 启动本地hexo 服务器，默认localhost:4000可以访问hexo deploy // 或者简写成hexo d 将本地修改，部署到远端hexo version // 显示hexo版本 7.其他常用操作 新建博文 hexo new &quot;the title of your blog&quot; 建议学习 写作 | Hexo 删除博文删除自动生成的hello world找到/source/_posts文件夹，里面放了所有我们写的博客，想删除哪篇，直接在这里删除，然后再重新发布到github，这篇博文就不见了 给博文添加tag和分类创建的新博文文件，打开之后顶部会有一段自动生成的文本，在其中加入tag和category标签即可指定tag和分类。 123456---title: blog titledate: 2016-07-20 10:59:31tag: hexo // 指定本篇文章tag标签category: hexo // 指定本片文章分类--- Hexo文章中插入图片 如何在Hexo文章中插入图片 | Bejond IO 编辑_config.ymlpost_asset_folder: true这样hexo会在每次使用hexo new title命令时在文章源文件目录下创建同名文件夹来存储资源. 实现 markdown中引用这么写： 1{% asset_img newRepository.png 创建repository%} asset_img 表示要引用图片, newRepository.png是标题, 后面的是图片显示的标题和悬浮时的提示。 8.安装Theme 终端cd到hexo所在文件夹执行如下命令：git clone https://github.com/iissnan/hexo-theme-next themes/next 将hexo目录下_config.yml里theme的名称landscape修改为next，重新部署就可以了。 fork me on github如果你访问我的个人博客，你会发现右上角有一个倾斜的fork me on github 图标，想要集成这个图标，去这里挑选你喜欢的样式，把样式代码复制过来。本地博客目录下的themes/next/layout/layout.swig文件，然后把你复制过来的样式代码粘贴到如下位置。 可以选择其他主题Themes | Hexo，方法同上。","link":"/2017/04/15/Mac搭建github-Page的Hexo免费个人博客/"},{"title":"【解决方案】如何在ionic项目中使用阿里巴巴iconfont图片库的资源","text":"操作步骤1，进入iconfont官网2，选择图片加入购物车 3，点击购物车，进入购物车列表，添加至项目 4，如下图，点击右上角加号，添加项目，点击确定 5，下载至本地 6，解压后浏览文件结构 7，导入项目中1.在lib下新建iconfont-&gt;fonts文件夹2.将字体文件引入fonts文件夹下，并修改名字3.将iconfont.css文件引入，并修改名字4.进入css文件修改文件路径（如下图） 8，使用1.引入css &lt;link rel=&quot;stylesheet&quot; href=&quot;lib/iconfont/jdzh.css&quot;&gt; &lt;i class=&quot;iconfont icon-all&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-cart&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-category&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-favorite&quot;&gt;&lt;/i&gt; ####说明 ‘iconfont’与.css文件中的与之对应 图标管理在开发过程中，可以由某人创建一个项目，点击右上方项目成员可以添加成员进入该项目，然后开发人员使用自己的账号登录，便可以在图标管理-&gt;我的项目-&gt;我发起的项目或者我参与的项目中，添加或删除图标，不会影响其他开发人员使用 如何新增svg到项目在开发过程中，可以将从UI那边得到的svg图片上传到iconfont“我上传的icon”里，然后加入购物车添加入库，然后点击购物车，之后操作同操作步骤3。 问题现象：前端代码发布在tomcat web服务器上可能会出现获取字体错误404，但是实际上服务器上是存在该字体的。 解决：在后台WEB-INF文件夹下找到web.xml，在最后添加如下代码，即可解决该问题。 &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ttf&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.woff&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.woff2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Symbol 使用 这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇文章 这种用法其实是做了一个svg的集合，与另外两种相比具有如下特点： 支持多色图标了，不再受单色限制。 通过一些技巧，支持像字体那样，通过font-size,color来调整样式。 兼容性较差，支持 ie9+,及现代浏览器。 浏览器渲染svg的性能一般，还不如png。 第一步：引入项目下面生成的symbol代码： &lt;script src=&quot;./iconfont.js&quot;&gt;&lt;/script&gt; 第二步：加入通用css代码（可在iconfont.css中引入）： .icon-base { width: 2em; height: 2em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; } 第三步：挑选相应图标并获取类名，应用于页面： 参考资料 http://www.mengyunzhi.com/share/development-environment/148-ionic-iconfont.html","link":"/2017/08/22/ionic引入icon-font/"},{"title":"service (服务)","text":"前言Service，这篇写的很好了，阅读，以后再总结。 Service 官方介绍Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。","link":"/2017/09/10/service/"},{"title":"内外网切换修改ip","text":"使用场景：经常需要切换内外网，设置内外网ip和dns。 123456789101112131415@echo offecho **************************************************************************echo * 修改IP地址、DNS *echo * *echo **************************************************************************echo 正在修改IP地址和DNS服务器地址,请耐心等待…………echo 正在更改本机IP地址...netsh interface ipv4 set address name=&quot;本地连接&quot; source=static addr=32.1.4.102 mask=255.255.255.0 gateway=32.1.4.254 gwmetric=0 &gt;nulecho 正在添加本机首选DNS服务器...netsh interface ipv4 set dns name=&quot;本地连接&quot; source=static addr=114.114.114.114 register=PRIMARYecho 正在添加备用DNS服务器...netsh interface ipv4 add dns name=&quot;本地连接&quot; addr=8.8.8.8echo 检查当前本机配置...ipconfig /allpause","link":"/2017/10/18/内外网切换修改ip/"},{"title":"在Android中引入Java8的lambda表达式（Android Studio3.0之前的实现方式）","text":"Help更新了Android Studio3.0，不断遇坑，而且还没办法解决的了。我遇到的坑是下不了v7支持库。https://dl.google.com/dl/android/maven2/com/android/support/appcompat-v7/26.1.0/appcompat-v7-26.1.0.pom这个东西一直下不了。 正题在根项目的build.gradle中添加这个classpath12345678910111213141516buildscript { repositories { jcenter() } dependencies { classpath &apos;com.android.tools.build:gradle:2.3.3&apos; //look here！！！！！！！！！！！！！！！！！！！！！！！！！！！ //lambda classpath &apos;me.tatarka:gradle-retrolambda:3.6.0&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files }} 然后，在项目的bulid.gradle中添加插件，并让其使用java8123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354apply plugin: &apos;com.android.application&apos;//look here！！！！！！！！！！！！！！！！！！！！！！！！！！！apply plugin: &apos;me.tatarka.retrolambda&apos;android { compileSdkVersion 26 buildToolsVersion &quot;26.0.2&quot; defaultConfig { applicationId &quot;com.zxl.mywork&quot; minSdkVersion 15 targetSdkVersion 26 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } //look here！！！！！！！！！！！！！！！！！！！！！！！！！！！ compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 }}dependencies { compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, { exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; }) compile &apos;com.android.support:appcompat-v7:26.+&apos; compile &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; testCompile &apos;junit:junit:4.12&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.0.1&apos; compile &apos;com.google.dagger:dagger:2.11&apos; annotationProcessor &apos;com.google.dagger:dagger-compiler:2.11&apos; compile &apos;io.reactivex.rxjava2:rxjava:2.0.8&apos; compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos; compile &apos;com.squareup.retrofit2:retrofit:2.2.0&apos; compile &apos;com.squareup.retrofit2:adapter-rxjava2:2.2.0&apos; compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos; compile &apos;com.squareup.okhttp3:okhttp:3.5.0&apos; compile &apos;com.squareup.okhttp3:logging-interceptor:3.6.0&apos; compile &apos;com.alibaba:fastjson:1.2.23&apos; compile &apos;com.jakewharton:butterknife:8.8.1&apos; compile &apos;com.orhanobut:logger:2.1.1&apos; compile &apos;com.github.bumptech.glide:glide:4.0.0&apos; annotationProcessor &apos;com.github.bumptech.glide:compiler:4.0.0&apos; compile &apos;com.tbruyelle.rxpermissions2:rxpermissions:0.9.3@aar&apos;}","link":"/2017/11/22/在Android中引入Java8的lambda表达式/"},{"title":"批处理实现自动备份","text":"使用场景背景：一个让人头疼的项目，功能没有完善，也没有经过严格的测试就匆忙上线。问题：更新代码需要增量更新，本地保存每天修改的内容。网上没有找到能满足这个要求的批处理文件，所以自己动手写了一个。 参考xcopy介绍 另附12345678@echo offecho 正在从&quot;E:\\hybrid_project\\wechat_xxxx&quot;备份到&quot;E:\\xxxx备份&quot;文件夹set dd=%date:~8,2%set mm=%date:~5,2%set yy=%date:~0,4%xcopy &quot;E:\\hybrid_project\\wechat_xxxx\\www&quot; &quot;E:\\xxxx备份\\%yy%-%mm%-%dd%\\&quot; /c /v /s /d:%mm%-%dd%-%yy%shutdown -sexit 说明实现了从开发文件夹下备份到备份文件夹功能备份文件夹内只有今日更新的内容（如果0点之后更新那就需要修改上面的时间）备份内容在备份文件夹内，并且以日期为文件夹名存放运行备份完成后执行关机 shutdown -s如果想实现自动备份可以配置自动执行","link":"/2017/09/16/批处理实现自动备份/"},{"title":"解决微信html、css、JavaScript缓存","text":"最近在开发微信项目，每次发版都需要手动刷新两遍才能看到新页面，微信缓存机制实在是太恶心。综合了网上的所有解决方案，结合项目的修改成本考虑，采用添加版本号来解决微信缓存问题，同时还兼顾微信的访问性能。 html原代码window.location.href=&quot;./a.html&quot; 修改后的代码window.location.href=&quot;./a.html?v=1&quot; css原代码&lt;link href=&quot;./a.css&quot; rel=&quot;stylesheet&quot;&gt; 修改后的代码&lt;link href=&quot;./a.css?v=1&quot; rel=&quot;stylesheet&quot;&gt; javascript原代码&lt;link href=&quot;./a.js&quot; type=&quot;text/javascript&quot;&gt; 修改后的代码&lt;link href=&quot;./a.js?v=1&quot; type=&quot;text/javascript&quot;&gt;","link":"/2017/10/24/解决微信html、css、JavaScript缓存/"},{"title":"ReactNative 组件之间通信","text":"1、组件之间通信有三种可能的关系 组件内部通信 父控件-&gt;子控件 子控件-&gt;父控件 没有任何嵌套的组件之间的传值（如兄弟组件之间传值） 2、组件内部用state123456789101112constructor(props) { super(props); this.state = { isOnline: true //组件 state };}render() { if(this.state.isOnline){ //...剩余代码 } //...剩余代码} 3、父子组件通信用 props1234567891011//父组件设置属性参数&lt;MyComponet parentValue={true} /&gt;//子组件class MyComponent extends Component { constructor(props) { super(props); //子组件获取属性 let parentValue = this.props.parentValue; } //...剩余代码} 4、子父组件通信用 props 子控件控制自己的state，然后通过父控件提供的回调方法，告诉父控件信息 本质是依赖于props来传递事件的引用，并通过回调的方式来实现 123456789101112131415//子组件class MyComponent extends Component { constructor(props) { super(props); } componentDidMount() { //子组件给父组件的方法传参 this.props.onChange(&apos;newVal&apos;); } render() { return ( &lt;View /&gt; ); }} 123456789101112131415161718192021//父组件class parentCpt extends Component { constructor(props) { super(props); this.state = { key: &apos;defVal&apos; }; } //父组件接受子组件的参数，并改变 state handleChange(val) { this.setState({ key: val }); } render() { //...剩余代码 return ( &lt;MyComponent onChange={(val) =&gt; {this.handleChange(val)}} /&gt; ); }} 使用Refs123456789101112131415//子组件class MyComponent extends Component { constructor(props) { super(props); } //开放的实例方法 doIt() { //...做点什么 } render() { return ( &lt;View /&gt; ); }} 12345678910111213141516//父组件class parentCpt extends Component { constructor(props) { super(props); } render() { //this.myCpt 保存组件的实例 return ( &lt;MyComponent ref={(c) =&gt; {this.myCpt = c;}} /&gt; ); } componentDidMount() { //调用组件的实例方法 this.myCpt.doIt(); }}","link":"/2017/08/02/组件之间通信/"}],"tags":[{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"activity","slug":"activity","link":"/tags/activity/"},{"name":"自定义view","slug":"自定义view","link":"/tags/自定义view/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"nexus私服","slug":"nexus私服","link":"/tags/nexus私服/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"设计原则","slug":"设计原则","link":"/tags/设计原则/"},{"name":"fragment","slug":"fragment","link":"/tags/fragment/"},{"name":"UML","slug":"UML","link":"/tags/UML/"},{"name":"面向对象","slug":"面向对象","link":"/tags/面向对象/"},{"name":"网络","slug":"网络","link":"/tags/网络/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"socks","slug":"socks","link":"/tags/socks/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"我","slug":"我","link":"/tags/我/"},{"name":"Hexo使用","slug":"Hexo使用","link":"/tags/Hexo使用/"},{"name":"iconfont","slug":"iconfont","link":"/tags/iconfont/"},{"name":"service","slug":"service","link":"/tags/service/"},{"name":"修改ip","slug":"修改ip","link":"/tags/修改ip/"},{"name":"批处理","slug":"批处理","link":"/tags/批处理/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"自动备份","slug":"自动备份","link":"/tags/自动备份/"},{"name":"微信缓存","slug":"微信缓存","link":"/tags/微信缓存/"},{"name":"组件通信","slug":"组件通信","link":"/tags/组件通信/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"私服","slug":"私服","link":"/categories/私服/"},{"name":"Java基础","slug":"Java基础","link":"/categories/Java基础/"},{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"我","slug":"我","link":"/categories/我/"},{"name":"UI设计","slug":"UI设计","link":"/categories/UI设计/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"ReactNative","slug":"ReactNative","link":"/categories/ReactNative/"}]}